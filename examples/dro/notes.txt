


Port "blocked" states:
- Pause/Resume are PFC related states
- I'm introducing a new state for each port, called the "blocked"/"unblocked" states.
- This new state is purely for me to be able to control the buffer as I require, without using pause
- An equivalent way of doing this is something like bringing a link down, or reducing the bandwidth of that link such that the buffer builds up in the switch.
- The main purpose is to be able to control which port is "blocked", resulting in a build up in the switch buffer, and subsequently triggering a pause frame to originate from that switch
- If I don't do this, then I have to find another way to trigger the pause frame sending.
- The steps of blocking a port of a switch:
	- The blocking starts from the CPU
	- Once CPU of a switch knows that this port is blocked, he will mark on his state.
	- Then, a packet is sent down to the switch to inform the switch which port is blocked.
	- Switch will mark on his state as well, then drop that packet
	- Each time a packet comes through and attempts to pass through the switch, switch must check if port is paused first. Pause takes priority over block.
	- If port is not paused, then switch will check if that port is blocked. If that port is blocked, switch will also send packet to CPU.
- The steps of releasing a port of a switch:
	- The releasing also starts from the CPU
	- Once CPU of the switch knows a port has been unblocked, he will mark on his state.
	- Then the CPU will loop through all ingress queues, and release any packets that may be released.
	- Then, a packet is sent down to the switch to inform the switch which port is unblocked.
	- Switch will mark on his state as well, then drop that packet.


DCFIT:

1. Implementing the port-based causality data structure (Traffic map)
	- An NxN bit-map, which we will use registers to represent.
	- We cannot create 2D register (or at least idk how), but we can do a simple 1D representation
		- For mapping of ingress port X to egress port Y, formula for the index is [MAX_PORTS*(y-1) + x] - 1
		- X and Y are 1-based, the actual index is 0-based.
	- This traffic map acts upon each regular packet that comes in.
	- So each time the packet comes in, it is processed and recognized by the switch.
	- The switch will not edit the traffic map if the packet is just forwarded normally.
	- Traffic map shall only be updated if the packet is forwarded to CPU, i.e. added to our switch buffer.
	- Just before sending to CPU, switch will mark the traffic map for that ingress-egress port pair with 1.
	- So even if multiple packets with the same pair is sent to CPU, that's fine, all will mark as 1.
	- Then, when the packet comes back from the CPU and is ready to be sent out, we need to check if it is the last packet in the buffer.
	- CPU header will contain a new bit that will indicate whether it is the last packet or not.
	- If the packet to be sent out is in fact the last packet, then the switch will unmark the traffic map for that ingress-egress port pair.

2. Implementing the checking message
	- Checking messages are piggybacked onto pause frames.
	- Reading each checking message will allow you to find out from exactly which switch and which port did that pause frame originate from.
	- When checking message is sent from one switch port to its upstream, the upstream will store the checking message at that receive port.
		- We can use a simple register for this, since only 1 checking message per port...?
	- Then, that same receive port will check the traffic map to find if there are any ingress port with relation with itself.
		- No for-loops in P4, so we might have to multicast this and perform this check at the egress.
	- If it has relation, it means that there are some packets in the buffer which have this i2e pair.
	- Then, those ports with relation, we check if we have paused the upstream
	- If upstream has been paused, then the checking message should be forwarded on, with the same data.
	Q: When should the stored checking messages at each port be cleared?
	- When a resume frame is received on that port.
	Q: What happens when a particular port receives 2 different checking messages (i.e. different originating switch or different sequence ID)?
	- Just replace with the newer one.
	Q: When a switch CPU creates a pause packet and wants to propagate it, we have to first check whether there is any stored checking message in any of the ingress ports, and whether we should use the stored checking message or create a new one. How should we decide this?
	- Consider a fresh situation, where a pause packet is triggered for the very first time. This pause packet will be triggered by the fact that a packet was put into the ingress buffer, and crossed the threshold mark. Let this switch be s1, and the pause packet will be generated with brand new checking message details and push out the ingress port. This is clear. Then, suppose s2 is the upstream switch that received this pause packet. s2 will store the checking message details at that receive port, then mark it as paused, and its other ports which has flows towards this receive port will start to have their ingress buffers filling up. Let this receive port be port 1, and we have another two ports, port 2 and port 3. Suppose s2 has flows p2->p1 and p2->p3. Supposed p2 buffer fills up and the triggering packet is a packet from the p2->p1 .... ??? 

3. Calculate how fast DCFIT detects deadlock
	- How to calculate timing between deadlock formation and deadlock detection?
	- First, let's pinpoint when is the exact time that these 2 events happen.
	- For deadlock formation, a deadlock is said to be formed once all switches in the CBD are paused by their upstream.
		- In our simple CBD topo, we block s3-p1, and the first pause packet is triggered from s3 towards s2.
		- So, deadlock is formed the instant that s3 receives a pause packet from s1, which completes the CBD loop.
		- 

received: 08:23:29.535
debugger: 08:23:29.535
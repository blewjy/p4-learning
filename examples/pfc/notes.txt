


Port "blocked" states:
- Pause/Resume are PFC related states
- I'm introducing a new state for each port, called the "blocked"/"unblocked" states.
- This new state is purely for me to be able to control the buffer as I require, without using pause
- An equivalent way of doing this is something like bringing a link down, or reducing the bandwidth of that link such that the buffer builds up in the switch.
- The main purpose is to be able to control which port is "blocked", resulting in a build up in the switch buffer, and subsequently triggering a pause frame to originate from that switch
- If I don't do this, then I have to find another way to trigger the pause frame sending.
- The steps of blocking a port of a switch:
	- The blocking starts from the CPU
	- Once CPU of a switch knows that this port is blocked, he will mark on his state.
	- Then, a packet is sent down to the switch to inform the switch which port is blocked.
	- Switch will mark on his state as well, then drop that packet
	- Each time a packet comes through and attempts to pass through the switch, switch must check if port is paused first. Pause takes priority over block.
	- If port is not paused, then switch will check if that port is blocked. If that port is blocked, switch will also send packet to CPU.
- The steps of releasing a port of a switch:
	- The releasing also starts from the CPU
	- Once CPU of the switch knows a port has been unblocked, he will mark on his state.
	- Then the CPU will loop through all ingress queues, and release any packets that may be released.
	- Then, a packet is sent down to the switch to inform the switch which port is unblocked.
	- Switch will mark on his state as well, then drop that packet.


DCFIT:

1. Implementing the port-based causality data structure (Traffic map)
	- An NxN bit-map, which we will use registers to represent.
	- We cannot create 2D register (or at least idk how), but we can do a simple 1D representation
		- For mapping of ingress port X to egress port Y, formula for the index is [MAX_PORTS*(y-1) + x] - 1
		- X and Y are 1-based, the actual index is 0-based.
	- This traffic map acts upon each regular packet that comes in.
	- So each time the packet comes in, it is processed and recognized by the switch.
	- The switch will not edit the traffic map if the packet is just forwarded normally.
	- Traffic map shall only be updated if the packet is forwarded to CPU, i.e. added to our switch buffer.
	- Just before sending to CPU, switch will mark the traffic map for that ingress-egress port pair with 1.
	- So even if multiple packets with the same pair is sent to CPU, that's fine, all will mark as 1.
	- Then, when the packet comes back from the CPU and is ready to be sent out, we need to check if it is the last packet in the buffer.
	- CPU header will contain a new bit that will indicate whether it is the last packet or not.
	- If the packet to be sent out is in fact the last packet, then the switch will unmark the traffic map for that ingress-egress port pair.

2. Implementing the checking message
	- Checking messages are piggybacked onto pause frames.
	- Reading each checking message will allow you to find out from exactly which switch and which port did that pause frame originate from.
	- When checking message is sent from one switch port to its upstream, the upstream will store the checking message at that receive port.
		- We can use a simple register for this, since only 1 checking message per port...?
	- Then, that same receive port will check the traffic map to find if there are any ingress port with relation with itself.
		- No for-loops in P4, so we might have to multicast this and perform this check at the egress.
	- If it has relation, it means that there are some packets in the buffer which have this i2e pair.
	- Then, those ports with relation, we check if we have paused the upstream
	- If upstream has been paused, then the checking message should be forwarded on, with the same data.
	Q: When should the stored checking messages at each port be cleared?
	- When a resume frame is received on that port.
	Q: What happens when a particular port receives 2 different checking messages (i.e. different originating switch or different sequence ID)?
	- Just replace with the newer one.
